#!/usr/bin/env python3

import argparse
import os
import sys
import io
import selectors
import shutil
import glob
import subprocess
import logging

#LOGDUR_INSTRUMENTED
#LOGDUR_KERNEL_CACHE
#HSA_TOOLS_LIB
#TRITON_LOGGER_LEVEL=3
#TRITON_HIP_LLD_PATH=${ROCM_HOME}/llvm/bin/ld.lld
#TRITON_ALWAYS_COMPILE=1
#TRITON_DISABLE_LINE_INFO=0
#AMDGCN_INSTRUMENTATION_FUNCTIONS_FILE=[some .bc file used by llvm plugin]
#LLVM_PASS_PLUGIN=[location of plugin.so]

op_run_env = {"LOGDUR_INSTRUMENTED": "true"} 

def console_log(*argv, indent_level=0):
    indent = ""
    if indent_level >= 1:
        indent = " " * 3 * indent_level + "|-> "  # spaces per indent level

    if len(argv) > 1:
        logging.info(indent + f"[{argv[0]}] {argv[1]}")
        logging.info(indent + f"[{argv[0]}] {argv[1]}")
    else:
        logging.info(indent + f"{argv[0]}")


def console_debug(*argv):
    if len(argv) > 1:
        logging.debug(f"[{argv[0]}] {argv[1]}")
    else:
        logging.debug(f"{argv[0]}")


def console_warning(*argv):
    if len(argv) > 1:
        for msg in argv:
            logging.info(f"[{msg}]")
        logging.warning(f"[{argv[0]}] {argv[1]}")
    else:
        logging.warning(f"{argv[0]}")


def capture_subprocess_output(subprocess_args, new_env=None):
    console_debug("subprocess", subprocess_args)
    # Start subprocess
    # bufsize = 1 means output is line buffered
    # universal_newlines = True is required for line buffering
    process = (
        subprocess.Popen(
            subprocess_args,
            bufsize=1,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
        )
        if new_env == None
        else subprocess.Popen(
            subprocess_args,
            bufsize=1,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
            env=new_env,
        )
    )
    print(process)
    # Create callback function for process output
    buf = io.StringIO()

    def handle_output(stream, mask):
        # Because the process' output is line buffered, there's only ever one
        # line to read when this function is called
        line = stream.readline()
        buf.write(line)
        console_warning(line.strip())

    # Register callback for an "available for read" event from subprocess' stdout stream
    selector = selectors.DefaultSelector()
    selector.register(process.stdout, selectors.EVENT_READ, handle_output)

    # Loop until subprocess is terminated
    while process.poll() is None:
        # Wait for events and handle them with their registered callbacks
        events = selector.select()
        for key, mask in events:
            callback = key.data
            callback(key.fileobj, mask)

    # Get process return code

def add_general_group(parser):
    general_group = parser.add_argument_group("General omniprobe arguments")

    general_group.add_argument (
        "-v",
        "--verbose",
        type=bool,
        metavar="",
        dest="verbose",
        required=False,
        default=False,
        help="\tVerbose output"
    )
    general_group.add_argument (
        "-t",
        "--type",
        type=str,
        metavar="",
        dest="type",
        required=False,
        default="memorytrace",
        help="\tSpecify the type of instrumentation to run"
    )
    
    general_group.add_argument (
        "-k",
        "--kernels",
        type=str,
        metavar="",
        dest="kernels",
        required=False,
        default="",
        help="\tKernel filters to define which kernels are instrumented"
    )
    
    general_group.add_argument (
        "-d",
        "--dispatches",
        type=str,
        metavar="",
        dest="dispatches",
        required=False,
        default="all",
        help="\tThe dispatches for which to capture output.  Valid options [all, random, 1]"
    )
    
    general_group.add_argument (
        "-c",
        "--cache-location",
        type=str,
        metavar="",
        dest="cache_location",
        required=False,
        default="all",
        help="\tThe location of the file system cache for instrumented kernels. For Triton this is typically found at $HOME/.triton/cache"
    )
    
    general_group.add_argument (
        "-l",
        "--log-location",
        type=str,
        metavar="",
        dest="log_location",
        required=False,
        default="console",
        help="\tThe location where all of your data should be logged. By default it will be to the console."
    )
    
    general_group.add_argument (
        "-a",
        "--analyzer",
        type=str,
        metavar="",
        dest="handler",
        required=False,
        default="",
        help="\tYour custom analyzer for processing data being streamed from instrumented kernels. Can be a shared library reference or a python module"
    )
    
    general_group.add_argument(
        "remaining",
        metavar="-- [ ...]",
        default=None,
        nargs=argparse.REMAINDER,
        help="\tProvide command for instrumenting after a double dash.",
    )
    return

def parse_args():
    parser = argparse.ArgumentParser(description = "Command-line interface for running intra-kernel analytics on AMD Instinct GPUs",
        prog="sentinel",
        formatter_class = lambda prog: argparse.RawTextHelpFormatter(
                prog, max_help_position=30
            ),
            usage="omniprobe [options] -- application"
           )
    parser._optionals.title = "Help"
    
    prog="omniprobe",
    allow_abbrev=False,
    formatter_class=lambda prog: argparse.RawTextHelpFormatter(prog, max_help_position=40)

    add_general_group(parser)
    parms = parser.parse_args()
    return parms

    
def main():
    print("omniprobe is a work of AMD Research and Advanced Development")
    print("Copyright (c) 2024 Advanced Micro Devices. All rights reserved.")
    parms  = parse_args()
    print(parms)
    if len(parms.remaining) != 0:
        print(f"Trying to run {parms.remaining[1:]}")
        capture_subprocess_output(parms.remaining[1:])

if __name__ == "__main__":
    main()
